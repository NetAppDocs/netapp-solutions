---
sidebar: sidebar
permalink: containers/devops_with_netapp/dwn_use_case_postmortem_with_restore.html
keywords: NetApp Astra Control, Astra Control Center, Application, Trident, Astra Trident, Helm, Operator, ONTAP, OpenShift, Kubernetes, Red Hat OpenShift, DevOps, Data Protection, CI/CD, Clone, App Restore, Post-mortem Analysis
summary: NetApp Astra Control Center offers a rich set of storage and application-aware data management services for stateful Kubernetes workloads, deployed in an on-prem environment, powered by NetApp’s trusted data protection technology.
---

= Leverage Astra Control to facilitate Post-mortem Analysis and Restore the Application
:hardbreaks:
:nofooter:
:icons: font
:linkattrs:
:imagesdir: ./../../media/

In the link:dwn_use_case_integrated_data_protection.html[first use-case], we demonstrated how to use NetApp Astra Control Center to protect your applications in Kubernetes. It signifies how to integrate application backups via Astra Control directly into your development workflow by using the Python SDK in the NetApp Astra toolkit. This approach allows for protection of  development and production environments by automating on-demand backups during the continuous integration and continuous deployment (CI/CD) process. With this extra layer of application-consistent data protection added to the CI/CD pipeline and the production applications, the development processes will be safe if something goes awry in the process, and it elevates the business continuity practices.

In a traditional workflow after encountering a failure when the application is upgraded to a new version, the development team would attempt to troubleshoot the issue in real time, based on enough bug reports being provided from customers. Or at the first sign of trouble, the team could attempt to redeploy the application to a parallel debug environment to take that process offline. They would redeploy an older code base from a previous version into production, which would restore the application to working order.

image::dwn_image9.jpg[Traditional workflow]

Although this approach would work, we would have to ensure that the state of the broken production app matched that of the version seen in production when the issues occurred. We would also have to spend time promoting the known-good build into production by fetching code from our repository and redeploying the machine images to restore the application to a good running state. Also, in this scenario, we didn’t consider whether the production database itself was corrupted by the faulty code. Ideally, there are separate backup processes in place for the database data too, but must we assume that they’re consistent with the state of the application as it was published? This is where the benefits of stateful and application-consistent backups, restores and clones with Astra Control really show their value.

First, we can use Astra Control to facilitate post-mortem analysis on the state of the application. We do this by cloning the buggy production version to a parallel testing environment in an application-consistent manner. Having this environment set aside in its bug-ridden state will enable us to troubleshoot the problem in real time.

Furthermore, Astra Control supports the in-place restore capability that allows us to restore the production application to a last acceptable backup (that preceded the afflicted version of code). The restored version assumes the position of the previous buggy production application, in an application-consistent and stateful manner, including the ingress IP previously assigned. As a result, customers accessing the front end would be unaware of the transition to the backup version.

image::dwn_image10.jpg[Post-mortem workflow]

== Use-case Validation Pre-requisites

The following tools or platforms were deployed and configured as pre-requisites:

. Red Hat OpenShift Container Platform
. NetApp Astra Trident installed on OpenShift with a backend to NetApp ONTAP system configured
. A default storageclass configured, pointing to NetApp ONTAP backend
. NetApp Astra Control Center installed on OpenShift cluster.
. OpenShift cluster added as a managed cluster to Astra Control Center.
. Jenkins installed on OpenShift cluster.
. Magento application is installed in the production environment.
. Production application is managed by Astra Control Center.
. Known-good backup(s) of the production application is captured via Astra Control.

== Clone & Restore Pipeline

Considering that the application has been upgraded to a new version and the application isn’t behaving as intended after the upgrade. Let's assume the data being returned by front-end queries doesn’t match the request, or the database has in fact been corrupted.

image::dwn_image12.jpg[Failed App]

. Log into Jenkins, and create a pipeline by clicking on `New Item` and then click on `Pipeline`.

. Copy the pipeline from Jenkinsfile https://github.com/NetApp/netapp-astra-toolkits/blob/main/ci_cd_examples/jenkins_pipelines/clone_for_postmortem_and_restore/Jenkinsfile[here^].

. Paste the pipeline into Jenkins pipeline section and then click on `Save`.

. Fill the parameters of the Jenkins pipeline with the respective details like the current Magento application version, Astra Control Center FQDN, API token, instance ID and application name or namespace along with the source and destination cluster names.
+
----
MAGENTO_VERSION = '2.4.1-debian-10-r14'
ASTRA_TOOLKIT_VERSION = '2.0.2'
ASTRA_API_TOKEN = 'xxxxx'
ASTRA_INSTANCE_ID = 'xxx-xxx-xxx-xxx-xxx'
ASTRA_FQDN = 'netapp-astra-control-center.org.example.com'
PROD_APP_NAME = 'magento-prod'
DEBUG_APP_NAME = 'magento-debug'
DEBUG_NAMESPACE = 'magento-debug'
PROD_KUBERNETES_CLUSTER = 'ocp-vmw'
DEBUG_KUBERNETES_CLUSTER = 'ocp-vmw'
----

. Then click on `Build Now`. It starts executing the pipeline and progresses through the steps. It first clones the application in current state to a debug environment, and then restores the application to the known-working backup.
+
image::dwn_image15.jpg[Post-mortem pipeline]

. Verify that the cloned application holds the bug-ridden version of the application.
+
image::dwn_image13.jpg[Failed Cloned App]

. Verify that the production environment is restored to a working backup and the application in production works as expected.
+
image::dwn_image14.jpg[Restored Prod App]

These two operations in tandem expedite our return to normal business operations. To see this use-case in action, watch the video link:dwn_videos_clone_for_postmortem_and_restore.html[here^]
